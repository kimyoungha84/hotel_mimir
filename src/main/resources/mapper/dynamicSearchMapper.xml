<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="kr.co.sist.util.mapper.DynamicSearchMapper">

<!-- 필터링 쿼리 -->
<sql id="filter">
<if test="filters != null and filters.size() > 0">
  <foreach collection="filters" item="filter">
    <choose>
      <when test="filter.operator.name() == 'EQ'">
        AND ${filter.column} = #{filter.value}
      </when>
      <when test="filter.operator.name() == 'LIKE'">
        AND ${filter.column} LIKE '%' || #{filter.value} || '%'
      </when>
      <when test="filter.operator.name() == 'IN'">
        <if test="filter.value != null and filter.value.size() > 1">
          AND ${filter.column} IN
          <foreach collection="filter.value" item="v" open="(" separator="," close=")">
            #{v}
          </foreach>
        </if>
        <if test="filter.value != null and filter.value.size() == 1">
          AND ${filter.column} = #{filter.value[0]}
        </if>
      </when>
          <!-- 날짜: BETWEEN (start + end) -->
        <when test="filter.operator.name() == 'TRUNC_BETWEEN'">
          AND TRUNC(${filter.column}) BETWEEN #{filter.value[0]} AND #{filter.value[1]}
        </when>

        <!-- 날짜: startDate만 있을 경우 -->
        <when test="filter.operator.name() == 'TRUNC_GREATER_EQUAL'">
          AND TRUNC(${filter.column}) &gt;= #{filter.value}
        </when>

        <!-- 날짜: endDate만 있을 경우 -->
        <when test="filter.operator.name() == 'TRUNC_LESS_EQUAL'">
          AND TRUNC(${filter.column}) &lt;= #{filter.value}
        </when>
    </choose>
  </foreach>
  </if>
</sql>
<!-- 필터링 쿼리 -->


<!-- 단순 셀렉트 -->
<sql id="diningSelectColumns">
  dining_id, dining_name, type, manager_name, dining_reg_date
</sql>

<sql id="faqSelectColumns">
  faq_num, faq_title, faq_content, faq_date
</sql>
<!-- 단순 셀렉트 -->

<!--///////////////////////////////// STAFF /////////////////////////////////-->

<sql id="whereFilter">
  <if test="filters != null and filters.size() > 0">
    <foreach collection="filters" item="filter">
      <if test="filter.column != 'permission_id_code'">
        <choose>
          <when test="filter.operator.name() == 'EQ'">
            AND ${filter.column} = #{filter.value}
          </when>
          <when test="filter.operator.name() == 'LIKE'">
            AND ${filter.column} LIKE '%' || #{filter.value} || '%'
          </when>
          <when test="filter.operator.name() == 'IN'">
            <foreach collection="filter.value" item="v" open="AND ${filter.column} IN (" separator="," close=")">
              #{v}
            </foreach>
          </when>
          <when test="filter.operator.name() == 'TRUNC_BETWEEN'">
            AND TRUNC(${filter.column}) BETWEEN #{filter.value[0]} AND #{filter.value[1]}
          </when>
          <when test="filter.operator.name() == 'TRUNC_GREATER_EQUAL'">
            AND TRUNC(${filter.column}) &gt;= #{filter.value}
          </when>
          <when test="filter.operator.name() == 'TRUNC_LESS_EQUAL'">
            AND TRUNC(${filter.column}) &lt;= #{filter.value}
          </when>
        </choose>
      </if>
    </foreach>
  </if>
</sql>


<sql id="havingFilter">
  <if test="filters != null and filters.size() > 0">
    <foreach collection="filters" item="filter">
      <if test="filter.column == 'permission_id_code'">
        HAVING INSTR(LISTAGG(p.permission_id_code, ','), #{filter.value}) > 0
      </if>
    </foreach>
  </if>
</sql>
<select id="searchStaff" resultType="kr.co.sist.util.domain.SearchDataDomain">
  SELECT staff_id, staff_name, dept_iden, position_identified_code, permission_ids, staff_status
  FROM (
    SELECT
      s.staff_id,
      s.staff_name,
      s.dept_iden,
      s.position_identified_code,
      LISTAGG(p.permission_id_code, ',') WITHIN GROUP (ORDER BY p.permission_id_code) AS permission_ids,
      s.staff_status,
      ROW_NUMBER() OVER (ORDER BY TO_DATE(s.date_of_employment, 'YYYY-MM-DD') DESC) AS rnum
    FROM staff s
    LEFT JOIN staff_permission p ON s.staff_id = p.staff_id
    WHERE 1=1
    <include refid="whereFilter"/>
    GROUP BY s.staff_id, s.staff_name, s.dept_iden, s.position_identified_code, s.staff_status, s.date_of_employment
    <include refid="havingFilter"/>
  )
  WHERE rnum BETWEEN #{offset} AND #{end}
</select>


<select id="countStaff" resultType="int">
  SELECT COUNT(*)
  FROM (
    SELECT s.staff_id
    FROM staff s
    LEFT JOIN staff_permission p ON s.staff_id = p.staff_id
    WHERE 1=1
    <include refid="whereFilter"/>
    GROUP BY s.staff_id, s.staff_name, s.dept_iden, s.position_identified_code, s.staff_status, s.date_of_employment
    <include refid="havingFilter"/>
  )
</select>

<!--///////////////////////////////// STAFF-END /////////////////////////////////-->



<!--///////////////////////////////// DINING /////////////////////////////////-->

<select id="searchDining" resultType="kr.co.sist.util.domain.SearchDataDomain">
 SELECT<include refid="diningSelectColumns"/>
FROM (
    SELECT <include refid="diningSelectColumns"/>,
           ROW_NUMBER() OVER (ORDER BY dining_reg_date DESC) rnum
    FROM dining
    WHERE 1=1
    <include refid="filter"/> <!-- 동적 필터 추가 -->
) 
WHERE rnum BETWEEN #{offset} AND #{end}
</select>

<select id="countDining" resultType="int">
     SELECT COUNT(*)
     FROM dining
     WHERE 1=1
  <include refid="filter"/>
</select>

<!--///////////////////////////////// DINING-END /////////////////////////////////-->


<!--///////////////////////////////// USER-DINING /////////////////////////////////-->

<sql id="userDiningSelectColumns">
  dining_id, dining_name, type, location, phone_number, dining_classification
</sql>


<select id="searchUserDining" resultType="kr.co.sist.util.domain.SearchDataDomain">
SELECT
  d.dining_id,
  d.dining_name,
  d.type,
  d.location,
  d.phone_number,
  d.dining_classification,
  di.image_url AS dining_main_image
FROM (
    SELECT
      dining_id, dining_name, type, location, phone_number, dining_classification, dining_reg_date,
      ROW_NUMBER() OVER (ORDER BY dining_reg_date DESC) rnum
    FROM dining
    WHERE 1=1
    <include refid="filter"/>
) d
LEFT JOIN dining_image di
  ON d.dining_id = di.dining_id
  AND di.image_type = 'MAIN'
  AND di.display_order = (
      SELECT MIN(display_order)
      FROM dining_image
      WHERE dining_id = d.dining_id
        AND image_type = 'MAIN'
  )
WHERE d.rnum BETWEEN #{offset} AND #{end}
  </select>


<!--///////////////////////////////// USER-DINING-END /////////////////////////////////-->


<!--///////////////////////////////// DINING_RESV /////////////////////////////////-->

<sql id="diningResvSelectColumnsAlias">
  r.RESERVATION_ID AS reservation_id,
  r.RESERVATION_NAME AS reservation_name,
  d.DINING_NAME AS dining_name,
  r.RESERVATION_DATE AS reservation_date,
  r.RESERVATION_STATUS AS reservation_status,
  r.RESERVATION_TYPE AS reservation_type
</sql>

<sql id="diningResvSelectColumns">
  reservation_id,
  reservation_name,
  dining_name,
  reservation_date,
  reservation_status,
  reservation_type
</sql>

<select id="searchDiningResv" resultType="kr.co.sist.util.domain.SearchDataDomain">
  SELECT <include refid="diningResvSelectColumns"/>
  FROM (
    SELECT <include refid="diningResvSelectColumnsAlias"/>,
           ROW_NUMBER() OVER (ORDER BY r.RESERVATION_TIME DESC) rnum
    FROM DINING_RESERVATION r
    LEFT JOIN DINING d ON r.DINING_ID = d.DINING_ID
    WHERE 1=1
    <include refid="filter"/>
  )
  WHERE rnum BETWEEN #{offset} AND #{end}
</select>

<select id="countDiningResv" resultType="int">
  SELECT COUNT(*)
  FROM DINING_RESERVATION r
  LEFT JOIN DINING d ON r.DINING_ID = d.DINING_ID
  WHERE 1=1
  <include refid="filter"/>
</select>

<!--///////////////////////////////// DINING_RESV-END /////////////////////////////////-->






<!--///////////////////////////////// FAQ /////////////////////////////////-->

<select id="searchFaq" resultType="kr.co.sist.util.domain.SearchDataDomain">
 SELECT <include refid="faqSelectColumns"/>
FROM (
    SELECT <include refid="faqSelectColumns"/>,
           ROW_NUMBER() OVER (ORDER BY faq_date DESC) rnum
    FROM faq
    WHERE 1=1
    <include refid="filter"/> <!-- 동적 필터 추가 -->
) 
WHERE rnum BETWEEN #{offset} AND #{end}
</select>

<select id="countFaq" resultType="int">
     SELECT COUNT(*)
     FROM faq
     WHERE 1=1
  <include refid="filter"/>
</select>

<!--///////////////////////////////// FAQ-END /////////////////////////////////-->

<!--///////////////////////////////// ROOM-RESV /////////////////////////////////-->

<sql id="roomResvFilter">
  <if test="filters != null and filters.size() > 0">
    <foreach collection="filters" item="filter">
      <choose>
        <!-- type_name 필터 -->
        <when test="filter.column == 'type_name'">
          AND rt.type_name = #{filter.value}
        </when>
        <!-- user_name 필터 (회원/비회원 모두 대응) -->
        <when test="filter.column == 'user_name'">
          AND (
            (u.user_name IS NOT NULL AND u.user_name LIKE '%' || #{filter.value} || '%')
            OR
            (nm.non_mem_name IS NOT NULL AND nm.non_mem_name LIKE '%' || #{filter.value} || '%')
          )
        </when>
        <!-- ismember(회원/비회원) 전용 처리 -->
        <when test="filter.column == 'ismember'">
          <choose>
            <when test="filter.value == '회원'">
              AND r.user_num IS NOT NULL
            </when>
            <when test="filter.value == '비회원'">
              AND r.user_num IS NULL
            </when>
          </choose>
        </when>
        <!-- 날짜: BETWEEN (start + end) -->
        <when test="filter.operator.name() == 'TRUNC_BETWEEN' and filter.column != 'ismember' and filter.column != 'user_name'">
          AND TRUNC(${filter.column}) BETWEEN #{filter.value[0]} AND #{filter.value[1]}
        </when>
        <!-- 날짜: startDate만 있을 경우 -->
        <when test="filter.operator.name() == 'TRUNC_GREATER_EQUAL' and filter.column != 'ismember' and filter.column != 'user_name'">
          AND TRUNC(${filter.column}) &gt;= #{filter.value}
        </when>
        <!-- 날짜: endDate만 있을 경우 -->
        <when test="filter.operator.name() == 'TRUNC_LESS_EQUAL' and filter.column != 'ismember' and filter.column != 'user_name'">
          AND TRUNC(${filter.column}) &lt;= #{filter.value}
        </when>
        <!-- 그 외 EQ, LIKE, IN 등 기존 처리 -->
        <when test="filter.operator.name() == 'EQ' and filter.column != 'ismember' and filter.column != 'user_name'">
          AND ${filter.column} = #{filter.value}
        </when>
        <when test="filter.operator.name() == 'LIKE' and filter.column != 'ismember' and filter.column != 'user_name'">
          AND ${filter.column} LIKE '%' || #{filter.value} || '%'
        </when>
        <when test="filter.operator.name() == 'IN' and filter.column != 'ismember' and filter.column != 'user_name'">
          <if test="filter.value != null and filter.value.size() > 1">
            AND ${filter.column} IN
            <foreach collection="filter.value" item="v" open="(" separator="," close=")">
              #{v}
            </foreach>
          </if>
          <if test="filter.value != null and filter.value.size() == 1">
            AND ${filter.column} = #{filter.value[0]}
          </if>
        </when>
        <!-- ...다른 연산자도 동일하게 처리 필요 -->
      </choose>
    </foreach>
  </if>
</sql>


<select id="searchRoomResv" resultType="kr.co.sist.util.domain.SearchDataDomain">
  SELECT *
  FROM (
    SELECT
      r.resv_id AS resvId,
      r.room_id AS roomId,
      rt.type_name AS typeName,
      CASE WHEN r.user_num IS NOT NULL THEN 1 ELSE 0 END AS isMember,
      COALESCE(u.user_name, nm.non_mem_name) AS userName,
      r.status AS status,
      ROW_NUMBER() OVER (ORDER BY r.resv_id DESC) rnum
    FROM
      reservation r
    LEFT JOIN
      room rm ON r.room_id = rm.room_id
    LEFT JOIN
      room_type rt ON rm.type_id = rt.type_id
    LEFT JOIN
      mimir_user u ON r.user_num = u.user_num
    LEFT JOIN
      non_member nm ON r.non_mem_id = nm.non_mem_id
    WHERE 1=1
      <include refid="roomResvFilter"/>
  )
  WHERE rnum BETWEEN #{offset} AND #{end}
</select>

<select id="countRoomResv" resultType="int">
  SELECT COUNT(*)
  FROM reservation r
  LEFT JOIN room rm ON r.room_id = rm.room_id
  LEFT JOIN room_type rt ON rm.type_id = rt.type_id
  LEFT JOIN mimir_user u ON r.user_num = u.user_num
  LEFT JOIN non_member nm ON r.non_mem_id = nm.non_mem_id
  WHERE 1=1
  <include refid="filter"/>
</select>

<!--///////////////////////////////// ROOM-RESV-END /////////////////////////////////-->

<!--///////////////////////////////// MEMBER /////////////////////////////////-->
<sql id="memberFilter">
  <if test="filters != null and filters.size() > 0">
    <foreach collection="filters" item="filter">
      <choose>
        <!-- 아이디 검색(통합)만 OR로 묶어서 처리 -->
        <when test="filter.column == 'user_id'">
          AND (
            email_id LIKE '%' || #{filter.value} || '%'
            OR oauth_id LIKE '%' || #{filter.value} || '%'
          )
        </when>
        <!-- 나머지는 기존 filter와 동일하게 처리 -->
        <when test="filter.operator.name() == 'EQ'">
          AND ${filter.column} = #{filter.value}
        </when>
        <when test="filter.operator.name() == 'LIKE'">
          AND ${filter.column} LIKE '%' || #{filter.value} || '%'
        </when>
        <!-- 기타 연산자도 필요시 추가 -->
      </choose>
    </foreach>
  </if>
</sql>



<select id="searchMember" resultType="kr.co.sist.util.domain.SearchDataDomain">
  SELECT
    user_num,
    login_type,
    CASE
      WHEN login_type = 'social' THEN oauth_id
      WHEN login_type = 'email' THEN email_id
      ELSE NULL
    END AS user_id,
    user_name,
    birth_date,
    tel,
    reg_time,
    use_yn
  FROM mimir_user
  WHERE 1=1
    <include refid="memberFilter"/>
  ORDER BY reg_time DESC
  OFFSET #{offset} - 1 ROWS FETCH NEXT #{pageSize} ROWS ONLY
</select>

<select id="countMember" resultType="int">
  SELECT COUNT(*)
  FROM mimir_user
  WHERE 1=1
    <include refid="memberFilter"/>
</select>

<!--///////////////////////////////// MEMBER-END /////////////////////////////////-->

<!--///////////////////////////////// ROOM-USER /////////////////////////////////-->

<sql id="roomUserFilter">
  <if test="filters != null and filters.size() > 0">
    <foreach collection="filters" item="filter">
      <choose>
        <when test="filter.operator.name() == 'EQ'">
          AND ${filter.column} = #{filter.value}
        </when>
        <when test="filter.operator.name() == 'LIKE'">
          AND ${filter.column} LIKE '%' || #{filter.value} || '%'
        </when>
        <when test="filter.operator.name() == 'IN'">
          <if test="filter.value != null and filter.value.size() > 1">
            AND ${filter.column} IN
            <foreach collection="filter.value" item="v" open="(" separator="," close=")">
              #{v}
            </foreach>
          </if>
          <if test="filter.value != null and filter.value.size() == 1">
            AND ${filter.column} = #{filter.value[0]}
          </if>
        </when>
        <!-- 필요시 BETWEEN 등 추가 -->
      </choose>
    </foreach>
  </if>
</sql>


<select id="searchRoom" parameterType="RoomSearchDTO" resultType="kr.co.sist.util.domain.SearchDataDomain">
SELECT
  roomId,
  bedName,
  typeName,
  viewName,
  floorType,
  countAvailableRooms,
  status
FROM (
  SELECT 
    r.room_id roomId,
    b.bed_Name bedName,
    t.type_Name typeName,
    v.view_Name viewName,
    NVL((
      SELECT status
      FROM (
        SELECT res.status
        FROM RESERVATION res
        WHERE res.room_id = r.room_id
        ORDER BY res.RESV_REG_DATE DESC
      )
      WHERE ROWNUM = 1
    ), '없음') AS status,
    CASE
      WHEN r.ROOM_FLOOR IN (6, 7) THEN '저층'
      WHEN r.ROOM_FLOOR = 8 THEN '중층'
      WHEN r.ROOM_FLOOR = 9 THEN '고층'
      WHEN r.ROOM_FLOOR = 10 THEN '초고층'
      ELSE '미정'
    END AS floorType,
    (
      SELECT COUNT(*)
      FROM room r2
      JOIN room_type rt2 ON r2.type_id = rt2.type_id
      JOIN view_type vt2 ON r2.view_id = vt2.view_id
      JOIN bed_type bt2 ON r2.bed_id = bt2.bed_id
      WHERE rt2.type_name = t.type_name
        AND vt2.view_name = v.view_name
        AND bt2.bed_name = b.bed_name
        AND NOT EXISTS (
          SELECT 1
          FROM reservation res
          WHERE res.room_id = r2.room_id
            AND res.status IN ('예약완료', '체크인')
            AND res.checkout_date &gt; TO_DATE(#{checkIn}, 'yyyy-MM-dd')
            AND res.checkin_date &lt; TO_DATE(#{checkOut}, 'yyyy-MM-dd')
        )
    ) AS countAvailableRooms,
    ROW_NUMBER() OVER (
      PARTITION BY t.type_Name, b.bed_Name, v.view_Name
      ORDER BY r.room_id
    ) rn
  FROM Room r
  JOIN Bed_Type b ON r.bed_Id = b.bed_Id
  JOIN Room_Type t ON r.type_Id = t.type_Id
  JOIN View_Type v ON r.view_Id = v.view_Id
  WHERE 1=1
    <include refid="roomUserFilter"/>
)
WHERE rn = 1
ORDER BY roomId
</select>




<!--///////////////////////////////// ROOM-USER-END /////////////////////////////////-->

</mapper>
